package setup

import (
	"fmt"
	"os"
	"path/filepath"
)

const cursorRulesTemplate = `# Beads Issue Tracking
# Auto-generated by 'fbd setup cursor' - do not remove these markers
# BEGIN BEADS INTEGRATION

This project uses [Beads (fbd)](https://github.com/steveyegge/fastbeads) for issue tracking.

## Core Rules
- Track ALL work in fbd (never use markdown TODOs or comment-based task lists)
- Use ` + "`fbd ready`" + ` to find available work
- Use ` + "`fbd create`" + ` to track new issues/tasks/bugs
- Use ` + "`fbd sync`" + ` at end of session to sync with git remote
- Git hooks auto-sync on commit/merge

## Quick Reference
` + "```bash" + `
fbd prime                              # Load complete workflow context
fbd ready                              # Show issues ready to work (no blockers)
fbd list --status=open                 # List all open issues
fbd create --title="..." --type=task  # Create new issue
fbd update <id> --status=in_progress  # Claim work
fbd close <id>                         # Mark complete
fbd dep add <issue> <depends-on>       # Add dependency (issue depends on depends-on)
fbd sync                               # Sync with git remote
` + "```" + `

## Workflow
1. Check for ready work: ` + "`fbd ready`" + `
2. Claim an issue: ` + "`fbd update <id> --status=in_progress`" + `
3. Do the work
4. Mark complete: ` + "`fbd close <id>`" + `
5. Sync: ` + "`fbd sync`" + ` (or let git hooks handle it)

## Context Loading
Run ` + "`fbd prime`" + ` to get complete workflow documentation in AI-optimized format (~1-2k tokens).

For detailed docs: see AGENTS.md, QUICKSTART.md, or run ` + "`fbd --help`" + `

# END BEADS INTEGRATION
`

// InstallCursor installs Cursor IDE integration
func InstallCursor() {
	rulesPath := ".cursor/rules/beads.mdc"

	fmt.Println("Installing Cursor integration...")

	// Ensure parent directory exists
	if err := EnsureDir(filepath.Dir(rulesPath), 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Write beads rules file (overwrite if exists)
	if err := atomicWriteFile(rulesPath, []byte(cursorRulesTemplate)); err != nil {
		fmt.Fprintf(os.Stderr, "Error: write rules: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\n✓ Cursor integration installed\n")
	fmt.Printf("  Rules: %s\n", rulesPath)
	fmt.Println("\nRestart Cursor for changes to take effect.")
}

// CheckCursor checks if Cursor integration is installed
func CheckCursor() {
	rulesPath := ".cursor/rules/beads.mdc"

	if _, err := os.Stat(rulesPath); os.IsNotExist(err) {
		fmt.Println("✗ Cursor integration not installed")
		fmt.Println("  Run: fbd setup cursor")
		os.Exit(1)
	}

	fmt.Println("✓ Cursor integration installed:", rulesPath)
}

// RemoveCursor removes Cursor integration
func RemoveCursor() {
	rulesPath := ".cursor/rules/beads.mdc"

	fmt.Println("Removing Cursor integration...")

	if err := os.Remove(rulesPath); err != nil {
		if os.IsNotExist(err) {
			fmt.Println("No rules file found")
			return
		}
		fmt.Fprintf(os.Stderr, "Error: failed to remove file: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("✓ Removed Cursor integration")
}
